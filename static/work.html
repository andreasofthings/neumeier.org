<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <title>Work â€” Andreas Neumeier</title>
        <style>
            html,
            body {
                height: 100%;
                margin: 0;
                background: #111;
                color: #e6e6e6;
                font-family: "Courier New", Courier, monospace;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            .wrap {
                box-sizing: border-box;
                padding: 40px;
                width: 60%;
                max-height: 90vh;
                overflow: auto;
            }
            .type {
                white-space: pre-wrap;
                font-size: 1.5rem;
                line-height: 1.6;
            }
            .cursor {
                display: inline-block;
                width: 8px;
                background: #e6e6e6;
                margin-left: 2px;
                animation: blink 0.8s steps(1) infinite;
                vertical-align: bottom;
            }
            @keyframes blink {
                50% {
                    opacity: 0;
                }
            }
        </style>
    </head>
    <body>
        <div class="wrap">
            <pre id="out" class="type"></pre>
        </div>
        <script>
            const phrase = "All work and no play makes Andreas a dull boy.";
            const out = document.getElementById("out");

            const typingMin = 50; // ms per char (min)
            const typingMax = 70; // ms per char (max)
            const linePause = 600; // pause after full line

            function escapeHtml(str) {
                return str
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;");
            }

            function render(text) {
                out.innerHTML =
                    escapeHtml(text) + '<span class="cursor"></span>';
            }

            async function sleep(ms) {
                return new Promise((r) => setTimeout(r, ms));
            }

            function randomTypingDelay() {
                return typingMin + Math.random() * (typingMax - typingMin);
            }

            function randInt(min, max) {
                return Math.floor(min + Math.random() * (max - min + 1));
            }

            function glitchWord(word, chance) {
                if (word.length < 2 || chance === 0) return word;

                if (Math.random() < chance) {
                    let chars = word.split("");
                    const glitchType = Math.random();

                    if (glitchType < 0.5) {
                        // Swap letters
                        const pos1 = randInt(0, chars.length - 1);
                        let pos2 = randInt(0, chars.length - 1);
                        while (pos1 === pos2) {
                            pos2 = randInt(0, chars.length - 1);
                        }
                        [chars[pos1], chars[pos2]] = [chars[pos2], chars[pos1]];
                    } else {
                        // Leave out a letter
                        const pos = randInt(0, chars.length - 1);
                        chars.splice(pos, 1);
                    }
                    return chars.join("");
                }
                return word;
            }

            async function typeText(text, currentText) {
                // type text character-by-character
                let acc = currentText;
                for (let i = 0; i < text.length; i++) {
                    acc += text[i];
                    render(acc);
                    await sleep(randomTypingDelay());
                    out.parentNode.scrollTop = out.parentNode.scrollHeight;
                }
                return acc;
            }

            async function typeLine(currentText, lineCount) {
                // layout glitches (whitespace, newlines)
                const maxLayoutGlitchesAfterLines = 50;
                const maxLayoutGlitchChance = 0.5;
                const layoutGlitchChance = Math.min(
                    maxLayoutGlitchChance,
                    (lineCount / maxLayoutGlitchesAfterLines) *
                        maxLayoutGlitchChance,
                );

                // word glitches (swapping/dropping letters)
                const startWordGlitchesAfterLines = 20; // start later
                const maxWordGlitchesAfterLines = 100; // take longer to reach max
                const maxWordGlitchChance = 0.3; // less frequent than layout glitches
                let wordGlitchChance = 0;
                if (lineCount > startWordGlitchesAfterLines) {
                    wordGlitchChance = Math.min(
                        maxWordGlitchChance,
                        ((lineCount - startWordGlitchesAfterLines) /
                            (maxWordGlitchesAfterLines -
                                startWordGlitchesAfterLines)) *
                            maxWordGlitchChance,
                    );
                }

                let acc = currentText || "";
                // maybe add 1..2 leading whitespace
                if (Math.random() < layoutGlitchChance) {
                    const leadCount = randInt(1, 2);
                    acc = await typeText(" ".repeat(leadCount), acc);
                }

                // type words with possible 1..2 extra spaces between them
                const words = phrase.split(" ");
                for (let w = 0; w < words.length; w++) {
                    let word = words[w];
                    word = glitchWord(word, wordGlitchChance);
                    acc = await typeText(word, acc);
                    if (w < words.length - 1) {
                        // always type one normal space
                        acc = await typeText(" ", acc);
                        // maybe add one or two extra spaces
                        if (Math.random() < layoutGlitchChance) {
                            const extra = randInt(1, 2);
                            acc = await typeText(" ".repeat(extra), acc);
                        }
                    }
                }

                // end of line pause
                await sleep(linePause);

                // decide whether to append newline or skip it
                if (Math.random() >= layoutGlitchChance) {
                    acc = await typeText("\n", acc);
                } else {
                    // skipping newline: render current state without adding '\n'
                    render(acc);
                }

                return acc;
            }

            (async function loop() {
                let acc = "";
                let lineCount = 0;
                while (true) {
                    acc = await typeLine(acc, lineCount);
                    lineCount++;
                }
            })();
        </script>
    </body>
</html>
